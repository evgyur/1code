diff --git a/scripts/download-claude-binary.mjs b/scripts/download-claude-binary.mjs
index f444d0c..a23aeeb 100644
--- a/scripts/download-claude-binary.mjs
+++ b/scripts/download-claude-binary.mjs
@@ -69,10 +69,15 @@ function downloadFile(url, destPath) {
             return request(res.headers.location)
           }
 
+          if (res.statusCode === 404) {
+            file.close()
+            if (fs.existsSync(destPath)) fs.unlinkSync(destPath)
+            return reject(new Error(`HTTP 404: Binary not found for version ${version} on platform ${platform.dir}. This version may not be available for Windows.`))
+          }
           if (res.statusCode !== 200) {
             file.close()
-            fs.unlinkSync(destPath)
-            return reject(new Error(`HTTP ${res.statusCode}`))
+            if (fs.existsSync(destPath)) fs.unlinkSync(destPath)
+            return reject(new Error(`HTTP ${res.statusCode}: ${res.statusMessage || 'Unknown error'}`))
           }
 
           const totalSize = parseInt(res.headers["content-length"], 10)
@@ -146,8 +151,9 @@ async function getLatestVersion() {
     // Fallback
   }
 
-  // Fallback to known version
-  return "2.1.5"
+  // Fallback to known working version (2.0.61 has Windows support)
+  console.warn("Could not fetch latest version, using fallback: 2.0.61")
+  return "2.0.61"
 }
 
 /**
@@ -174,11 +180,21 @@ async function downloadPlatform(version, platformKey, manifest) {
   }
 
   const expectedHash = platformManifest.checksum
-  const downloadUrl = `${DIST_BASE}/${version}/${platform.dir}/claude`
+  // For Windows, the URL needs to use 'claude.exe', not 'claude'
+  // For other platforms, it's just 'claude'
+  const binaryUrlName = platformKey === "win32-x64" ? "claude.exe" : "claude"
+  const downloadUrl = `${DIST_BASE}/${version}/${platform.dir}/${binaryUrlName}`
 
   console.log(`\nDownloading Claude Code for ${platformKey}...`)
   console.log(`  URL: ${downloadUrl}`)
   console.log(`  Size: ${(platformManifest.size / 1024 / 1024).toFixed(1)} MB`)
+  
+  // Check if platform is available in manifest
+  if (!platformManifest) {
+    console.error(`  ✗ Platform ${platform.dir} not available for version ${version}`)
+    console.error(`  Available platforms: ${Object.keys(manifest.platforms || {}).join(", ")}`)
+    return false
+  }
 
   // Check if already downloaded with correct hash
   if (fs.existsSync(targetPath)) {
@@ -225,8 +241,20 @@ async function main() {
   console.log("Claude Code Binary Downloader")
   console.log("=============================\n")
 
-  // Get version
-  const version = specifiedVersion || (await getLatestVersion())
+  // Get version - for Windows, use known working version since 2.1.5 doesn't have Windows binaries
+  const currentPlatform = downloadAll ? null : `${process.platform}-${process.arch}`
+  let version = specifiedVersion
+  
+  if (!version) {
+    if (currentPlatform === "win32-x64") {
+      // Windows: use known working version (2.1.5 doesn't have Windows binaries)
+      console.log("Windows detected - using known working version 2.0.61")
+      version = "2.0.61"
+    } else {
+      version = await getLatestVersion()
+    }
+  }
+  
   console.log(`Version: ${version}`)
 
   // Fetch manifest
@@ -236,6 +264,23 @@ async function main() {
   let manifest
   try {
     manifest = await fetchJson(manifestUrl)
+    
+    // Verify platform support
+    if (currentPlatform) {
+      const platformDir = PLATFORMS[currentPlatform]?.dir
+      if (!platformDir) {
+        console.error(`Unknown platform: ${currentPlatform}`)
+        process.exit(1)
+      }
+      if (!manifest.platforms || !manifest.platforms[platformDir]) {
+        console.error(`✗ Version ${version} does not have support for ${currentPlatform}`)
+        if (manifest.platforms) {
+          console.error(`  Available platforms: ${Object.keys(manifest.platforms).join(", ")}`)
+        }
+        process.exit(1)
+      }
+      console.log(`✓ Version ${version} has support for ${currentPlatform}`)
+    }
   } catch (error) {
     console.error(`Failed to fetch manifest: ${error.message}`)
     process.exit(1)
diff --git a/src/main/lib/git/worktree.ts b/src/main/lib/git/worktree.ts
index 280d406..3615340 100644
--- a/src/main/lib/git/worktree.ts
+++ b/src/main/lib/git/worktree.ts
@@ -2,6 +2,7 @@ import { execFile } from "node:child_process";
 import { randomBytes } from "node:crypto";
 import { mkdir, readFile, stat } from "node:fs/promises";
 import { join } from "node:path";
+import * as os from "node:os";
 import { promisify } from "node:util";
 import simpleGit from "simple-git";
 import {
@@ -905,7 +906,8 @@ export async function createWorktreeForChat(
 		const baseBranch = selectedBaseBranch || await getDefaultBranch(projectPath);
 
 		const branch = generateBranchName();
-		const worktreesDir = join(process.env.HOME || "", ".21st", "worktrees");
+		const homeDir = os.homedir();
+		const worktreesDir = join(homeDir, ".21st", "worktrees");
 		const worktreePath = join(worktreesDir, projectId, chatId);
 
 		await createWorktree(projectPath, branch, worktreePath, `origin/${baseBranch}`);
diff --git a/src/main/lib/trpc/routers/claude.ts b/src/main/lib/trpc/routers/claude.ts
index 59fe647..c615136 100644
--- a/src/main/lib/trpc/routers/claude.ts
+++ b/src/main/lib/trpc/routers/claude.ts
@@ -13,7 +13,7 @@ import {
   logRawClaudeMessage,
   type UIMessageChunk,
 } from "../../claude"
-import { chats, claudeCodeCredentials, getDatabase, subChats } from "../../db"
+import { chats, claudeCodeCredentials, getDatabase, projects, subChats } from "../../db"
 import { publicProcedure, router } from "../index"
 import { buildAgentsOption } from "./agent-utils"
 
@@ -221,28 +221,130 @@ export const claudeRouter = router({
             error instanceof Error ? error.message : String(error)
           const errorStack = error instanceof Error ? error.stack : undefined
 
-          console.error(`[claude] ${context}:`, errorMessage)
-          if (errorStack) console.error("[claude] Stack:", errorStack)
+          console.error(`\n╔═══════════════════════════════════════════════════════════╗`)
+          console.error(`║ ⚠️  ERROR EMITTED TO FRONTEND                              ║`)
+          console.error(`╠═══════════════════════════════════════════════════════════╣`)
+          console.error(`║ Context: ${context.padEnd(47)}║`)
+          console.error(`║ Error: ${errorMessage.substring(0, 47).padEnd(47)}║`)
+          console.error(`║ CWD: ${input.cwd.padEnd(53)}║`)
+          console.error(`║ Mode: ${input.mode.padEnd(53)}║`)
+          console.error(`║ SubChatId: ${input.subChatId.padEnd(45)}║`)
+          console.error(`╚═══════════════════════════════════════════════════════════╝`)
+          if (errorStack) {
+            console.error(`\nERROR STACK:\n${errorStack}\n`)
+          }
 
-          // Send detailed error to frontend (safely)
+          // Send detailed error to frontend (safely) - ALWAYS include debug info
           safeEmit({
             type: "error",
             errorText: `${context}: ${errorMessage}`,
-            // Include extra debug info
-            ...(process.env.NODE_ENV !== "production" && {
-              debugInfo: {
-                context,
-                cwd: input.cwd,
-                mode: input.mode,
-                PATH: process.env.PATH?.slice(0, 200),
-              },
-            }),
+            debugInfo: {
+              context,
+              category: "UNKNOWN",
+              cwd: input.cwd,
+              mode: input.mode,
+              subChatId: input.subChatId,
+              errorMessage,
+              ...(errorStack && { errorStack }),
+            },
           } as UIMessageChunk)
         }
 
         ;(async () => {
+          console.error(`\n╔═══════════════════════════════════════════════════════════╗`)
+          console.error(`║ BACKEND: ASYNC FUNCTION STARTED                           ║`)
+          console.error(`╠═══════════════════════════════════════════════════════════╣`)
+          console.error(`║ SubChatId: ${input.subChatId.padEnd(47)}║`)
+          console.error(`║ ChatId: ${input.chatId.padEnd(51)}║`)
+          console.error(`║ CWD: ${input.cwd.padEnd(53)}║`)
+          console.error(`║ Mode: ${input.mode.padEnd(53)}║`)
+          console.error(`║ Prompt: "${input.prompt.substring(0, 45)}${input.prompt.length > 45 ? '...' : ''}"`.padEnd(59) + `║`)
+          console.error(`║ Prompt Length: ${String(input.prompt.length).padEnd(42)}║`)
+          console.error(`║ SessionId: ${(input.sessionId || 'none').padEnd(48)}║`)
+          console.error(`║ Images: ${String(input.images?.length || 0).padEnd(51)}║`)
+          console.error(`╚═══════════════════════════════════════════════════════════╝\n`)
+          
+          // Early validation - check cwd exists before doing anything
+          console.error(`[BACKEND] Step 1: Validating CWD...`)
+          console.error(`[BACKEND] Original CWD: ${input.cwd}`)
+          
+          // Resolve relative paths to absolute
+          let resolvedCwd: string
+          try {
+            if (path.isAbsolute(input.cwd)) {
+              resolvedCwd = input.cwd
+            } else {
+              // Resolve relative to user's home directory (worktrees are in ~/.21st/worktrees)
+              const homeDir = os.homedir()
+              resolvedCwd = path.resolve(homeDir, input.cwd)
+            }
+            console.error(`[BACKEND] Resolved CWD: ${resolvedCwd}`)
+          } catch (resolveError) {
+            const errorMsg = resolveError instanceof Error ? resolveError.message : String(resolveError)
+            console.error(`[BACKEND] ✗ CWD RESOLUTION FAILED: ${errorMsg}`)
+            emitError(new Error(`Failed to resolve CWD path: ${input.cwd} - ${errorMsg}`), "Workspace path resolution error")
+            safeEmit({ type: "finish" } as UIMessageChunk)
+            safeComplete()
+            return
+          }
+          
           try {
+            const cwdStat = await fs.stat(resolvedCwd)
+            if (!cwdStat.isDirectory()) {
+              console.error(`[BACKEND] ✗ CWD VALIDATION FAILED: Not a directory`)
+              emitError(new Error(`CWD is not a directory: ${resolvedCwd}`), "Invalid workspace path")
+              safeEmit({ type: "finish" } as UIMessageChunk)
+              safeComplete()
+              return
+            }
+            console.error(`[BACKEND] ✓ CWD VALIDATED: ${resolvedCwd}`)
+            
+            // Update input.cwd to the resolved absolute path for use in query
+            input.cwd = resolvedCwd
+          } catch (cwdError) {
+            const errorMsg = cwdError instanceof Error ? cwdError.message : String(cwdError)
+            console.error(`[BACKEND] ✗ CWD VALIDATION FAILED: ${errorMsg}`)
+            console.error(`[BACKEND] Original CWD: ${input.cwd}`)
+            console.error(`[BACKEND] Resolved CWD: ${resolvedCwd}`)
+            console.error(`[BACKEND] Error Details:`, cwdError)
+            
+            // Try to get project path from database as fallback
+            try {
+              console.error(`[BACKEND] Attempting fallback: Getting project path from database...`)
+              const db = getDatabase()
+              const chat = db.select().from(chats).where(eq(chats.id, input.chatId)).get()
+              if (chat?.projectId) {
+                const project = db.select().from(projects).where(eq(projects.id, chat.projectId)).get()
+                if (project?.path) {
+                  const projectPathExists = await fs.stat(project.path).then(() => true).catch(() => false)
+                  if (projectPathExists) {
+                    console.error(`[BACKEND] ✓ Found project path: ${project.path}`)
+                    resolvedCwd = project.path
+                    input.cwd = project.path
+                    console.error(`[BACKEND] Using project path as fallback (worktree missing)`)
+                  } else {
+                    throw new Error(`Project path exists in DB but is inaccessible: ${project.path}`)
+                  }
+                } else {
+                  throw new Error(`Project not found in database`)
+                }
+              } else {
+                throw new Error(`Chat has no projectId`)
+              }
+            } catch (fallbackError) {
+              const fallbackMsg = fallbackError instanceof Error ? fallbackError.message : String(fallbackError)
+              console.error(`[BACKEND] ✗ Fallback failed: ${fallbackMsg}`)
+              emitError(new Error(`CWD does not exist or is inaccessible: ${resolvedCwd} (original: ${input.cwd}) - ${errorMsg}\n\nWorktree may have been deleted. Please recreate the workspace.`), "Workspace path error")
+              safeEmit({ type: "finish" } as UIMessageChunk)
+              safeComplete()
+              return
+            }
+          }
+          
+          try {
+            console.error(`[BACKEND] Step 2: Accessing database...`)
             const db = getDatabase()
+            console.error(`[BACKEND] ✓ Database accessed`)
 
             // 1. Get existing messages from DB
             const existing = db
@@ -285,10 +387,16 @@ export const claudeRouter = router({
             }
 
             // 3. Get Claude SDK
+            console.error(`[BACKEND] Step 3: Loading Claude SDK...`)
             let claudeQuery
             try {
               claudeQuery = await getClaudeQuery()
+              console.error(`[BACKEND] ✓ Claude SDK loaded successfully`)
             } catch (sdkError) {
+              const errorMsg = sdkError instanceof Error ? sdkError.message : String(sdkError)
+              const errorStack = sdkError instanceof Error ? sdkError.stack : undefined
+              console.error(`[BACKEND] ✗ SDK LOAD FAILED: ${errorMsg}`)
+              console.error(`[BACKEND] Error Stack:`, errorStack)
               emitError(sdkError, "Failed to load Claude SDK")
               console.log(`[SD] M:END sub=${subId} reason=sdk_load_error n=${chunkCount}`)
               safeEmit({ type: "finish" } as UIMessageChunk)
@@ -482,7 +590,36 @@ export const claudeRouter = router({
             }
 
             // Get bundled Claude binary path
+            console.error(`[BACKEND] Step 4: Checking Claude binary...`)
             const claudeBinaryPath = getBundledClaudeBinaryPath()
+            console.error(`[BACKEND] Binary Path: ${claudeBinaryPath}`)
+            
+            // Validate binary exists
+            try {
+              const binaryExists = await fs.access(claudeBinaryPath).then(() => true).catch(() => false)
+              if (!binaryExists) {
+                console.error(`[BACKEND] ✗ BINARY NOT FOUND at: ${claudeBinaryPath}`)
+                emitError(
+                  new Error(`Claude binary not found at: ${claudeBinaryPath}\n\nRun 'bun run claude:download' to download it.`),
+                  "Claude binary missing"
+                )
+                safeEmit({ type: "finish" } as UIMessageChunk)
+                safeComplete()
+                return
+              }
+              console.error(`[BACKEND] ✓ Binary found and accessible`)
+            } catch (binaryError) {
+              const errorMsg = binaryError instanceof Error ? binaryError.message : String(binaryError)
+              console.error(`[BACKEND] ✗ BINARY CHECK FAILED: ${errorMsg}`)
+              console.error(`[BACKEND] Binary Path: ${claudeBinaryPath}`)
+              emitError(
+                new Error(`Failed to check Claude binary: ${errorMsg}`),
+                "Binary validation error"
+              )
+              safeEmit({ type: "finish" } as UIMessageChunk)
+              safeComplete()
+              return
+            }
 
             const resumeSessionId = input.sessionId || existingSessionId || undefined
             console.log(`[SD] Query options - cwd: ${input.cwd}, projectPath: ${input.projectPath || "(not set)"}, mcpServers: ${mcpServersForSdk ? Object.keys(mcpServersForSdk).join(", ") : "(none)"}`)
@@ -617,15 +754,34 @@ export const claudeRouter = router({
             }
 
             // 5. Run Claude SDK
-            let stream
+            console.error(`[BACKEND] Step 5: Creating Claude query stream...`)
+            console.error(`[BACKEND] Query Options:`, {
+              cwd: input.cwd,
+              mode: input.mode,
+              hasToken: !!claudeCodeToken,
+              binaryPath: claudeBinaryPath,
+              resumeSessionId: resumeSessionId || "new",
+              promptType: typeof prompt,
+              promptLength: typeof prompt === "string" ? prompt.length : "async",
+            })
+            
+            let stream: AsyncIterable<any>
             try {
               stream = claudeQuery(queryOptions)
+              console.error(`[BACKEND] ✓ Query stream created`)
+              
+              // Verify stream is actually an async iterable
+              if (!stream || typeof stream[Symbol.asyncIterator] !== "function") {
+                throw new Error(`Stream is not async iterable: ${typeof stream}`)
+              }
+              console.error(`[BACKEND] ✓ Stream is async iterable`)
             } catch (queryError) {
-              console.error(
-                "[CLAUDE] ✗ Failed to create SDK query:",
-                queryError,
-              )
-              emitError(queryError, "Failed to start Claude query")
+              const errorMessage = queryError instanceof Error ? queryError.message : String(queryError)
+              const errorStack = queryError instanceof Error ? queryError.stack : undefined
+              console.error(`[BACKEND] ✗ QUERY CREATION FAILED: ${errorMessage}`)
+              console.error(`[BACKEND] Error Stack:`, errorStack)
+              console.error(`[BACKEND] Query Options:`, JSON.stringify(queryOptions, null, 2))
+              emitError(queryError, `Failed to start Claude query: ${errorMessage}`)
               console.log(`[SD] M:END sub=${subId} reason=query_error n=${chunkCount}`)
               safeEmit({ type: "finish" } as UIMessageChunk)
               safeComplete()
@@ -638,10 +794,32 @@ export const claudeRouter = router({
             let exitPlanModeToolCallId: string | null = null // Track ExitPlanMode's toolCallId
 
             try {
+              console.error(`[BACKEND] Step 6: Starting stream iteration...`)
+              let streamIterationCount = 0
+              let lastMessageType: string | null = null
+              
               for await (const msg of stream) {
-                if (abortController.signal.aborted) break
+                if (abortController.signal.aborted) {
+                  console.error(`[BACKEND] Stream aborted at iteration ${streamIterationCount}`)
+                  break
+                }
 
                 messageCount++
+                streamIterationCount++
+                lastMessageType = (msg as any)?.type || "unknown"
+                
+                if (streamIterationCount === 1) {
+                  console.error(`\n╔═══════════════════════════════════════════════════════════╗`)
+                  console.error(`║ FIRST MESSAGE FROM STREAM                                 ║`)
+                  console.error(`╠═══════════════════════════════════════════════════════════╣`)
+                  console.error(`║ Type: ${String(lastMessageType).padEnd(53)}║`)
+                  console.error(`╚═══════════════════════════════════════════════════════════╝`)
+                  console.error(`\nFULL MESSAGE:\n${JSON.stringify(msg, null, 2)}\n`)
+                }
+                
+                if (streamIterationCount <= 3) {
+                  console.error(`[BACKEND] Message ${streamIterationCount}: type=${lastMessageType}`)
+                }
 
                 // Log raw message for debugging
                 logRawClaudeMessage(input.chatId, msg)
